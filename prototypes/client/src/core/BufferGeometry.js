import{Vector3}from'../math/Vector3.js';import{Box3}from'../math/Box3.js';import{EventDispatcher}from'./EventDispatcher.js';import{BufferAttribute,Float32BufferAttribute,Uint16BufferAttribute,Uint32BufferAttribute}from'./BufferAttribute.js';import{Sphere}from'../math/Sphere.js';import{DirectGeometry}from'./DirectGeometry.js';import{Object3D}from'./Object3D.js';import{Matrix4}from'../math/Matrix4.js';import{Matrix3}from'../math/Matrix3.js';import{_Math}from'../math/Math.js';import{arrayMax}from'../utils.js';import{GeometryIdCount}from'./Geometry.js';function BufferGeometry(){Object.defineProperty(this,'id',{value:GeometryIdCount()}),this.uuid=_Math.generateUUID(),this.name='',this.type='BufferGeometry',this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:Infinity}}BufferGeometry.MaxIndex=65535,Object.assign(BufferGeometry.prototype,EventDispatcher.prototype,{isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(a){this.index=Array.isArray(a)?new(65535<arrayMax(a)?Uint32BufferAttribute:Uint16BufferAttribute)(a,1):a},addAttribute:function(a,b){return!1===(b&&b.isBufferAttribute)&&!1===(b&&b.isInterleavedBufferAttribute)?(console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).'),void this.addAttribute(a,new BufferAttribute(arguments[1],arguments[2]))):'index'===a?(console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.'),void this.setIndex(b)):(this.attributes[a]=b,this)},getAttribute:function(a){return this.attributes[a]},removeAttribute:function(a){return delete this.attributes[a],this},addGroup:function(a,b,c){this.groups.push({start:a,count:b,materialIndex:c===void 0?0:c})},clearGroups:function(){this.groups=[]},setDrawRange:function(a,b){this.drawRange.start=a,this.drawRange.count=b},applyMatrix:function(a){var b=this.attributes.position;void 0!==b&&(a.applyToBufferAttribute(b),b.needsUpdate=!0);var c=this.attributes.normal;if(void 0!==c){var d=new Matrix3().getNormalMatrix(a);d.applyToBufferAttribute(c),c.needsUpdate=!0}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:function(){var a=new Matrix4;return function(b){return a.makeRotationX(b),this.applyMatrix(a),this}}(),rotateY:function(){var a=new Matrix4;return function(b){return a.makeRotationY(b),this.applyMatrix(a),this}}(),rotateZ:function(){var a=new Matrix4;return function(b){return a.makeRotationZ(b),this.applyMatrix(a),this}}(),translate:function(){var a=new Matrix4;return function(b,c,d){return a.makeTranslation(b,c,d),this.applyMatrix(a),this}}(),scale:function(){var a=new Matrix4;return function(b,c,d){return a.makeScale(b,c,d),this.applyMatrix(a),this}}(),lookAt:function(){var a=new Object3D;return function(b){a.lookAt(b),a.updateMatrix(),this.applyMatrix(a.matrix)}}(),center:function(){this.computeBoundingBox();var a=this.boundingBox.getCenter().negate();return this.translate(a.x,a.y,a.z),a},setFromObject:function(a){var b=a.geometry;if(a.isPoints||a.isLine){var c=new Float32BufferAttribute(3*b.vertices.length,3),d=new Float32BufferAttribute(3*b.colors.length,3);if(this.addAttribute('position',c.copyVector3sArray(b.vertices)),this.addAttribute('color',d.copyColorsArray(b.colors)),b.lineDistances&&b.lineDistances.length===b.vertices.length){var e=new Float32BufferAttribute(b.lineDistances.length,1);this.addAttribute('lineDistance',e.copyArray(b.lineDistances))}null!==b.boundingSphere&&(this.boundingSphere=b.boundingSphere.clone()),null!==b.boundingBox&&(this.boundingBox=b.boundingBox.clone())}else a.isMesh&&b&&b.isGeometry&&this.fromGeometry(b);return this},updateFromObject:function(a){var b=a.geometry;if(a.isMesh){var c=b.__directGeometry;if(!0===b.elementsNeedUpdate&&(c=void 0,b.elementsNeedUpdate=!1),void 0===c)return this.fromGeometry(b);c.verticesNeedUpdate=b.verticesNeedUpdate,c.normalsNeedUpdate=b.normalsNeedUpdate,c.colorsNeedUpdate=b.colorsNeedUpdate,c.uvsNeedUpdate=b.uvsNeedUpdate,c.groupsNeedUpdate=b.groupsNeedUpdate,b.verticesNeedUpdate=!1,b.normalsNeedUpdate=!1,b.colorsNeedUpdate=!1,b.uvsNeedUpdate=!1,b.groupsNeedUpdate=!1,b=c}var d;return!0===b.verticesNeedUpdate&&(d=this.attributes.position,void 0!==d&&(d.copyVector3sArray(b.vertices),d.needsUpdate=!0),b.verticesNeedUpdate=!1),!0===b.normalsNeedUpdate&&(d=this.attributes.normal,void 0!==d&&(d.copyVector3sArray(b.normals),d.needsUpdate=!0),b.normalsNeedUpdate=!1),!0===b.colorsNeedUpdate&&(d=this.attributes.color,void 0!==d&&(d.copyColorsArray(b.colors),d.needsUpdate=!0),b.colorsNeedUpdate=!1),b.uvsNeedUpdate&&(d=this.attributes.uv,void 0!==d&&(d.copyVector2sArray(b.uvs),d.needsUpdate=!0),b.uvsNeedUpdate=!1),b.lineDistancesNeedUpdate&&(d=this.attributes.lineDistance,void 0!==d&&(d.copyArray(b.lineDistances),d.needsUpdate=!0),b.lineDistancesNeedUpdate=!1),b.groupsNeedUpdate&&(b.computeGroups(a.geometry),this.groups=b.groups,b.groupsNeedUpdate=!1),this},fromGeometry:function(a){return a.__directGeometry=new DirectGeometry().fromGeometry(a),this.fromDirectGeometry(a.__directGeometry)},fromDirectGeometry:function(a){var b=new Float32Array(3*a.vertices.length);if(this.addAttribute('position',new BufferAttribute(b,3).copyVector3sArray(a.vertices)),0<a.normals.length){var c=new Float32Array(3*a.normals.length);this.addAttribute('normal',new BufferAttribute(c,3).copyVector3sArray(a.normals))}if(0<a.colors.length){var d=new Float32Array(3*a.colors.length);this.addAttribute('color',new BufferAttribute(d,3).copyColorsArray(a.colors))}if(0<a.uvs.length){var e=new Float32Array(2*a.uvs.length);this.addAttribute('uv',new BufferAttribute(e,2).copyVector2sArray(a.uvs))}if(0<a.uvs2.length){var f=new Float32Array(2*a.uvs2.length);this.addAttribute('uv2',new BufferAttribute(f,2).copyVector2sArray(a.uvs2))}if(0<a.indices.length){var g=65535<arrayMax(a.indices)?Uint32Array:Uint16Array,h=new g(3*a.indices.length);this.setIndex(new BufferAttribute(h,1).copyIndicesArray(a.indices))}for(var j in this.groups=a.groups,a.morphTargets){for(var k=[],m=a.morphTargets[j],n=0,i=m.length;n<i;n++){var l=m[n],o=new Float32BufferAttribute(3*l.length,3);k.push(o.copyVector3sArray(l))}this.morphAttributes[j]=k}if(0<a.skinIndices.length){var p=new Float32BufferAttribute(4*a.skinIndices.length,4);this.addAttribute('skinIndex',p.copyVector4sArray(a.skinIndices))}if(0<a.skinWeights.length){var q=new Float32BufferAttribute(4*a.skinWeights.length,4);this.addAttribute('skinWeight',q.copyVector4sArray(a.skinWeights))}return null!==a.boundingSphere&&(this.boundingSphere=a.boundingSphere.clone()),null!==a.boundingBox&&(this.boundingBox=a.boundingBox.clone()),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Box3);var a=this.attributes.position;a===void 0?this.boundingBox.makeEmpty():this.boundingBox.setFromBufferAttribute(a),(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){var a=new Box3,b=new Vector3;return function(){null===this.boundingSphere&&(this.boundingSphere=new Sphere);var c=this.attributes.position;if(c){var d=this.boundingSphere.center;a.setFromBufferAttribute(c),a.getCenter(d);for(var e=0,f=0,g=c.count;f<g;f++)b.x=c.getX(f),b.y=c.getY(f),b.z=c.getZ(f),e=Math.max(e,d.distanceToSquared(b));this.boundingSphere.radius=Math.sqrt(e),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}}(),computeFaceNormals:function(){},computeVertexNormals:function(){var a=this.index,b=this.attributes,c=this.groups;if(b.position){var d=b.position.array;if(b.normal===void 0)this.addAttribute('normal',new BufferAttribute(new Float32Array(d.length),3));else for(var e=b.normal.array,f=0,g=e.length;f<g;f++)e[f]=0;var h,i,k,l=b.normal.array,m=new Vector3,n=new Vector3,o=new Vector3,p=new Vector3,q=new Vector3;if(a){var r=a.array;0===c.length&&this.addGroup(0,r.length);for(var s=0,j=c.length;s<j;++s)for(var t=c[s],u=t.start,v=t.count,f=u,g=u+v;f<g;f+=3)h=3*r[f+0],i=3*r[f+1],k=3*r[f+2],m.fromArray(d,h),n.fromArray(d,i),o.fromArray(d,k),p.subVectors(o,n),q.subVectors(m,n),p.cross(q),l[h]+=p.x,l[h+1]+=p.y,l[h+2]+=p.z,l[i]+=p.x,l[i+1]+=p.y,l[i+2]+=p.z,l[k]+=p.x,l[k+1]+=p.y,l[k+2]+=p.z}else for(var f=0,g=d.length;f<g;f+=9)m.fromArray(d,f),n.fromArray(d,f+3),o.fromArray(d,f+6),p.subVectors(o,n),q.subVectors(m,n),p.cross(q),l[f]=p.x,l[f+1]=p.y,l[f+2]=p.z,l[f+3]=p.x,l[f+4]=p.y,l[f+5]=p.z,l[f+6]=p.x,l[f+7]=p.y,l[f+8]=p.z;this.normalizeNormals(),b.normal.needsUpdate=!0}},merge:function(a,b){if(!1===(a&&a.isBufferGeometry))return void console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',a);b===void 0&&(b=0);var c=this.attributes;for(var d in c)if(a.attributes[d]!==void 0)for(var e=c[d],f=e.array,g=a.attributes[d],h=g.array,k=g.itemSize,l=0,i=k*b;l<h.length;l++,i++)f[i]=h[l];return this},normalizeNormals:function(){for(var a,b,c,d,e=this.attributes.normal,f=0,g=e.count;f<g;f++)a=e.getX(f),b=e.getY(f),c=e.getZ(f),d=1/Math.sqrt(a*a+b*b+c*c),e.setXYZ(f,a*d,b*d,c*d)},toNonIndexed:function(){if(null===this.index)return console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.'),this;var a=new BufferGeometry,b=this.index.array,c=this.attributes;for(var d in c){for(var e=c[d],f=e.array,g=e.itemSize,h=new f.constructor(b.length*g),k=0,m=0,n=0,i=b.length;n<i;n++){k=b[n]*g;for(var l=0;l<g;l++)h[m++]=f[k++]}a.addAttribute(d,new BufferAttribute(h,g))}return a},toJSON:function(){var a={metadata:{version:4.5,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};if(a.uuid=this.uuid,a.type=this.type,''!==this.name&&(a.name=this.name),void 0!==this.parameters){var b=this.parameters;for(var c in b)void 0!==b[c]&&(a[c]=b[c]);return a}a.data={attributes:{}};var d=this.index;if(null!==d){var e=Array.prototype.slice.call(d.array);a.data.index={type:d.array.constructor.name,array:e}}var f=this.attributes;for(var c in f){var g=f[c],e=Array.prototype.slice.call(g.array);a.data.attributes[c]={itemSize:g.itemSize,type:g.array.constructor.name,array:e,normalized:g.normalized}}var h=this.groups;0<h.length&&(a.data.groups=JSON.parse(JSON.stringify(h)));var i=this.boundingSphere;return null!==i&&(a.data.boundingSphere={center:i.center.toArray(),radius:i.radius}),a},clone:function(){return new BufferGeometry().copy(this)},copy:function(a){var b,c,d;this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.name=a.name;var e=a.index;null!==e&&this.setIndex(e.clone());var f=a.attributes;for(b in f){var g=f[b];this.addAttribute(b,g.clone())}var h=a.morphAttributes;for(b in h){var i=[],j=h[b];for(c=0,d=j.length;c<d;c++)i.push(j[c].clone());this.morphAttributes[b]=i}var k=a.groups;for(c=0,d=k.length;c<d;c++){var l=k[c];this.addGroup(l.start,l.count,l.materialIndex)}var m=a.boundingBox;null!==m&&(this.boundingBox=m.clone());var n=a.boundingSphere;return null!==n&&(this.boundingSphere=n.clone()),this.drawRange.start=a.drawRange.start,this.drawRange.count=a.drawRange.count,this},dispose:function(){this.dispatchEvent({type:'dispose'})}});export{BufferGeometry};